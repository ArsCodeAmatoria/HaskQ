---
title: "Core Types and Functions"
description: "Complete API reference for HaskQ's fundamental quantum types and operations"
date: "2025-01-01"
author: "HaskQ API Team"
---

# Core Types and Functions

Complete reference for HaskQ's type-safe quantum programming interface.

## Fundamental Types

### Qubit

The fundamental unit of quantum information in HaskQ.

```haskell
-- | A quantum bit with linear type guarantees
data Qubit :: Type

-- | Basis states
data Bit = Zero | One
  deriving (Eq, Show, Ord, Enum)

-- | Measurement bases
data Basis = ComputationalBasis | DiagonalBasis
  deriving (Eq, Show)
```

### Circuit Monad

The `Circ` monad encapsulates quantum computations while enforcing linearity.

```haskell
-- | Quantum circuit monad with linear types
newtype Circ a = Circ (State CircuitState a)

-- | Run a quantum circuit
runCircuit :: Circ a -> IO a

-- | Circuit composition
(>>>) :: Circ a -> (a -> Circ b) -> Circ b
```

## Qubit Operations

### Creation and Initialization

```haskell
-- | Create a qubit in the |0⟩ state
createQubit :: Bit -> Circ Qubit
createQubit Zero = -- Implementation
createQubit One  = -- Implementation

-- | Alternative initialization
qinit :: Bool -> Circ Qubit
qinit False = createQubit Zero
qinit True  = createQubit One

-- | Create multiple qubits with a computation
withQubits :: Int -> ([Qubit] -> Circ a) -> Circ a
```

**Example:**
```haskell
-- Create a single qubit
q <- createQubit Zero

-- Create multiple qubits
result <- withQubits 3 $ \[q1, q2, q3] -> do
  q1' <- hadamard q1
  (q1'', q2') <- cnot q1' q2
  pure (q1'', q2', q3)
```

### Single-Qubit Gates

#### Pauli Gates

```haskell
-- | Pauli-X gate (bit flip): |0⟩ ↔ |1⟩
gateX :: Qubit -> Circ Qubit

-- | Pauli-Y gate: |0⟩ → i|1⟩, |1⟩ → -i|0⟩  
gateY :: Qubit -> Circ Qubit

-- | Pauli-Z gate (phase flip): |1⟩ → -|1⟩
gateZ :: Qubit -> Circ Qubit
```

**Matrix Representations:**
- **X**: `[[0,1],[1,0]]`
- **Y**: `[[0,-i],[i,0]]`
- **Z**: `[[1,0],[0,-1]]`

#### Hadamard Gate

```haskell
-- | Hadamard gate: creates superposition
-- |0⟩ → (|0⟩ + |1⟩)/√2, |1⟩ → (|0⟩ - |1⟩)/√2
hadamard :: Qubit -> Circ Qubit
```

**Matrix**: `[[1/√2, 1/√2], [1/√2, -1/√2]]`

#### Rotation Gates

```haskell
-- | Rotation around X-axis
rotateX :: Double -> Qubit -> Circ Qubit

-- | Rotation around Y-axis  
rotateY :: Double -> Qubit -> Circ Qubit

-- | Rotation around Z-axis
rotateZ :: Double -> Qubit -> Circ Qubit

-- | Phase gate (special case of Z rotation)
phase :: Double -> Qubit -> Circ Qubit
phase θ = rotateZ θ

-- | T gate (π/4 phase)
gateT :: Qubit -> Circ Qubit
gateT = phase (pi/4)

-- | S gate (π/2 phase)
gateS :: Qubit -> Circ Qubit
gateS = phase (pi/2)
```

**Rotation Matrices:**
- **RX(θ)**: `[[cos(θ/2), -i*sin(θ/2)], [-i*sin(θ/2), cos(θ/2)]]`
- **RY(θ)**: `[[cos(θ/2), -sin(θ/2)], [sin(θ/2), cos(θ/2)]]`
- **RZ(θ)**: `[[e^(-iθ/2), 0], [0, e^(iθ/2)]]`

### Two-Qubit Gates

#### CNOT Gate

```haskell
-- | Controlled-NOT gate
-- |00⟩ → |00⟩, |01⟩ → |01⟩, |10⟩ → |11⟩, |11⟩ → |10⟩
cnot :: Qubit -> Qubit -> Circ (Qubit, Qubit)
```

**Matrix**: `[[1,0,0,0],[0,1,0,0],[0,0,0,1],[0,0,1,0]]`

#### Controlled Gates

```haskell
-- | Controlled-Z gate
controlledZ :: Qubit -> Qubit -> Circ (Qubit, Qubit)

-- | Controlled phase gate
controlledPhase :: Double -> Qubit -> Qubit -> Circ (Qubit, Qubit)

-- | Controlled-U gate (general)
controlledU :: (Qubit -> Circ Qubit) -> Qubit -> Qubit -> Circ (Qubit, Qubit)

-- | SWAP gate
swap :: Qubit -> Qubit -> Circ (Qubit, Qubit)

-- | Controlled-SWAP (Fredkin gate)
controlledSwap :: Qubit -> Qubit -> Qubit -> Circ (Qubit, Qubit, Qubit)
```

### Three-Qubit Gates

```haskell
-- | Toffoli gate (CCNOT)
toffoli :: Qubit -> Qubit -> Qubit -> Circ (Qubit, Qubit, Qubit)

-- | CCZ gate
ccz :: Qubit -> Qubit -> Qubit -> Circ (Qubit, Qubit, Qubit)
```

## Measurement

### Basic Measurement

```haskell
-- | Measure a qubit in computational basis
measureQubit :: Qubit -> Circ Bit

-- | Measure multiple qubits
measureQubits :: [Qubit] -> Circ [Bit]

-- | Measure with basis choice
measureInBasis :: Basis -> Qubit -> Circ Bit
```

### Measurement with Post-Selection

```haskell
-- | Measure and return both result and remaining qubit
measure :: Qubit -> Circ (Bit, Qubit)

-- | Conditional measurement
measureIf :: (Bit -> Bool) -> Qubit -> Circ (Maybe Bit, Qubit)
```

**Example:**
```haskell
-- Basic measurement
q <- createQubit Zero >>= hadamard
result <- measureQubit q  -- Result is Zero or One with 50% probability

-- Measurement preserving qubit
q <- createQubit Zero >>= hadamard  
(bit, q') <- measure q
-- bit is measurement result, q' is post-measurement qubit
```

## Complex Quantum Operations

### Quantum Fourier Transform

```haskell
-- | Quantum Fourier Transform
qft :: [Qubit] -> Circ [Qubit]

-- | Inverse Quantum Fourier Transform
inverseQFT :: [Qubit] -> Circ [Qubit]

-- | QFT on specific qubits
qftN :: Int -> [Qubit] -> Circ [Qubit]
```

### Amplitude Amplification

```haskell
-- | Grover's amplitude amplification
amplifyAmplitude :: (Qubit -> Circ Bool) -> Qubit -> Circ Qubit

-- | Grover operator
groverOperator :: ([Qubit] -> Circ [Qubit]) -> [Qubit] -> Circ [Qubit]
```

## Type-Level Safety

### Linear Types

HaskQ uses GHC's linear types to enforce quantum no-cloning:

```haskell
{-# LANGUAGE LinearTypes #-}

-- | Linear function type
f :: Qubit %1 -> Circ Qubit

-- | Consuming a qubit exactly once
consume :: Qubit %1 -> Circ ()

-- | This would be a type error:
-- clone :: Qubit -> (Qubit, Qubit)  -- Illegal!
```

### Phantom Types

```haskell
-- | Statically tracked qubit count
data QCircuit (n :: Nat) a

-- | Type-safe qubit indexing
data QIndex (n :: Nat) (i :: Nat) where
  QIndex :: (i < n) => QIndex n i

-- | Access qubit by index
(!?) :: QReg n -> QIndex n i -> Qubit
```

## Simulation and Backends

### State Vector Simulation

```haskell
-- | Classical simulation parameters
data SimConfig = SimConfig
  { maxQubits :: Int        -- Maximum qubits (default: 20)
  , precision :: Double     -- Numerical precision
  , randomSeed :: Maybe Int -- Random seed for measurements
  }

-- | Run circuit with simulation backend
simulate :: SimConfig -> Circ a -> IO a

-- | Get full state vector
getStateVector :: [Qubit] -> Circ (Vector (Complex Double))

-- | Probability distribution
getProbabilities :: [Qubit] -> Circ (Vector Double)
```

### Quantum Information

```haskell
-- | Von Neumann entropy
vonNeumannEntropy :: [Qubit] -> Circ Double

-- | Quantum mutual information
mutualInformation :: [Qubit] -> [Qubit] -> Circ Double

-- | Entanglement entropy
entanglementEntropy :: [Qubit] -> [Qubit] -> Circ Double

-- | Quantum coherence measures
quantumCoherence :: Qubit -> Circ Double

-- | Fidelity between states
fidelity :: [Qubit] -> [Qubit] -> Circ Double
```

## Error Handling

### Circuit Validation

```haskell
-- | Validate circuit structure
validateCircuit :: Circ a -> Either CircuitError (Circ a)

-- | Error types
data CircuitError
  = QubitIndexError Int
  | DimensionMismatch Int Int
  | InvalidGate String
  | ResourceExhausted String
  deriving (Show, Eq)
```

### Debugging

```haskell
-- | Print circuit statistics
debugCircuit :: Circ a -> Circ a

-- | Trace qubit states
traceQubit :: String -> Qubit -> Circ Qubit

-- | Circuit depth analysis
circuitDepth :: Circ a -> Int

-- | Gate count analysis
gateCount :: Circ a -> Map String Int
```

## Extensions and Advanced Features

### Custom Gates

```haskell
-- | Define custom single-qubit gate
customGate :: Matrix (Complex Double) -> Qubit -> Circ Qubit

-- | Define custom two-qubit gate
customGate2 :: Matrix (Complex Double) -> Qubit -> Qubit -> Circ (Qubit, Qubit)

-- | Parameterized gates
parameterizedGate :: [Double] -> Qubit -> Circ Qubit
```

### Noise Models

```haskell
-- | Apply noise to qubits
addNoise :: NoiseModel -> Qubit -> Circ Qubit

-- | Noise model types
data NoiseModel
  = Depolarizing Double    -- Depolarizing noise
  | Amplitude Double       -- Amplitude damping  
  | Phase Double           -- Phase damping
  | Thermal Double Double  -- Thermal noise
```

## Performance Considerations

### Memory Usage

- **State vector simulation**: O(2ⁿ) memory for n qubits
- **Recommended limits**: n ≤ 20 qubits for classical simulation
- **Sparse simulation**: Available for circuits with limited entanglement

### Optimization

```haskell
-- | Optimize circuit for execution
optimizeCircuit :: Circ a -> Circ a

-- | Parallel execution for independent operations
parallelCircuits :: [Circ a] -> Circ [a]

-- | Memoization for repeated subcircuits
memoizeCircuit :: (Eq a) => Circ a -> Circ a
```

## Integration with Classical Code

### I/O Operations

```haskell
-- | Read classical data into quantum state
encodeClassical :: [Double] -> Circ [Qubit]

-- | Extract classical information
decodeQuantum :: [Qubit] -> Circ [Double]

-- | Interface with classical algorithms
hybrid :: (a -> IO b) -> a -> Circ b
```

---

*This API reference covers HaskQ's core functionality. For advanced features and theoretical applications, see the [Advanced Algorithms](/docs/tutorials/advanced-algorithms) and [Theoretical Connections](/docs/core-concepts/theoretical-connections) documentation.* 